const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const fs = require('fs');
const path = require('path');

// Configuration renforc√©e
const ADMIN_NUMBER = '237679199601@c.us';
const DATA_FILE = path.join(__dirname, 'users_data.json');
const USAGE_DURATION = 30 * 24 * 60 * 60 * 1000; // 30 jours
const CONNECTION_CODE_DURATION = 10 * 60 * 1000; // 10 minutes
const MAX_RETRY_ATTEMPTS = 3;
const HEALTH_CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes

// Variables globales optimis√©es
let userData = {
    users: {},
    accessCodes: {},
    groups: {},
    connectionCode: null,
    connectionCodeExpiry: 0
};

let isReady = false;
let lastActivity = Date.now();
let retryCount = 0;
let healthCheckInterval;

// Fonctions utilitaires am√©lior√©es
function loadData() {
    try {
        if (fs.existsSync(DATA_FILE)) {
            const data = fs.readFileSync(DATA_FILE, 'utf8');
            if (data.trim()) {
                const parsed = JSON.parse(data);
                userData = { 
                    users: {},
                    accessCodes: {},
                    groups: {},
                    connectionCode: null,
                    connectionCodeExpiry: 0,
                    ...parsed 
                };
                console.log('‚úÖ Donn√©es charg√©es avec succ√®s');
                return true;
            }
        }
        console.log('üìù Nouveau fichier de donn√©es cr√©√©');
        saveData();
        return true;
    } catch (error) {
        console.error('‚ùå Erreur chargement donn√©es:', error.message);
        createBackup();
        return false;
    }
}

function saveData() {
    try {
        cleanupBeforeSave();
        const dataToSave = {
            ...userData,
            lastSave: Date.now()
        };
        
        fs.writeFileSync(DATA_FILE, JSON.stringify(dataToSave, null, 2));
        console.log('üíæ Donn√©es sauvegard√©es');
        return true;
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde:', error.message);
        createBackup();
        return false;
    }
}

function createBackup() {
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupFile = path.join(__dirname, `backup_${timestamp}.json`);
        fs.writeFileSync(backupFile, JSON.stringify(userData, null, 2));
        console.log(`üîÑ Backup cr√©√©: ${backupFile}`);
    } catch (error) {
        console.error('‚ùå Erreur backup:', error.message);
    }
}

function cleanupBeforeSave() {
    const now = Date.now();
    
    // Nettoyer code de connexion expir√©
    if (userData.connectionCodeExpiry && now > userData.connectionCodeExpiry) {
        userData.connectionCode = null;
        userData.connectionCodeExpiry = 0;
    }
    
    // Nettoyer codes d'acc√®s expir√©s (24h)
    Object.keys(userData.accessCodes).forEach(phone => {
        const codeData = userData.accessCodes[phone];
        if (now - codeData.generated > 24 * 60 * 60 * 1000) {
            delete userData.accessCodes[phone];
        }
    });
}

// Gestion des codes am√©lior√©e
function generateConnectionCode() {
    const code = Math.floor(10000000 + Math.random() * 90000000).toString();
    userData.connectionCode = code;
    userData.connectionCodeExpiry = Date.now() + CONNECTION_CODE_DURATION;
    saveData();
    
    console.log(`üîë Code de connexion: ${code.substring(0,4)} ${code.substring(4)}`);
    return code;
}

function verifyConnectionCode(inputCode) {
    const now = Date.now();
    const cleanInput = inputCode.replace(/\s/g, '');
    
    if (!userData.connectionCode || now > userData.connectionCodeExpiry) {
        return false;
    }
    
    return userData.connectionCode === cleanInput;
}

function generateAccessCode(phoneNumber) {
    const code = Math.random().toString(36).substring(2, 8).toUpperCase();
    userData.accessCodes[phoneNumber] = {
        code: code,
        generated: Date.now(),
        used: false
    };
    saveData();
    return code;
}

function isUserAuthorized(phoneNumber) {
    const user = userData.users[phoneNumber];
    if (!user || !user.authorized) return false;
    
    const now = Date.now();
    const isValid = (now - user.authorizedAt) < USAGE_DURATION;
    
    if (!isValid && user.authorized) {
        user.authorized = false;
        saveData();
    }
    
    return isValid;
}

function validateAccessCode(phoneNumber, code) {
    const accessData = userData.accessCodes[phoneNumber];
    if (!accessData || accessData.used || accessData.code !== code.toUpperCase()) {
        return false;
    }
    
    accessData.used = true;
    userData.users[phoneNumber] = {
        authorized: true,
        authorizedAt: Date.now(),
        phoneNumber: phoneNumber
    };
    
    saveData();
    return true;
}

// Configuration client optimis√©e pour la stabilit√©
const client = new Client({
    authStrategy: new LocalAuth({
        clientId: "whatsapp-bot-stable",
        dataPath: './auth_data'
    }),
    puppeteer: {
        headless: true,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--disable-web-security',
            '--disable-features=VizDisplayCompositor',
            '--no-first-run',
            '--disable-gpu',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-renderer-backgrounding',
            '--memory-pressure-off',
            '--max_old_space_size=4096'
        ],
        timeout: 120000, // 2 minutes
        slowMo: 50 // Ralentir pour √©viter les erreurs
    }
});

// Gestion am√©lior√©e des √©v√©nements
client.on('qr', (qr) => {
    console.log('\n' + '='.repeat(50));
    console.log('üîó CONNEXION WHATSAPP - 2 OPTIONS');
    console.log('='.repeat(50));
    
    console.log('\nüì± OPTION 1 - QR Code:');
    qrcode.generate(qr, { small: true });
    
    console.log('\nüî¢ OPTION 2 - Code de connexion:');
    const connectionCode = generateConnectionCode();
    console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    console.log('‚îÇ      CODE DE CONNEXION WHATSAPP        ‚îÇ');
    console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
    console.log(`‚îÇ           ${connectionCode.substring(0,4)} ${connectionCode.substring(4)}              ‚îÇ`);
    console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
    console.log('‚îÇ      Valide pendant 10 minutes         ‚îÇ');
    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
    
    console.log('\nüìù Instructions:');
    console.log('1. Ouvrez WhatsApp sur votre mobile');
    console.log('2. Menu ‚Üí Appareils li√©s');
    console.log('3. "Lier un appareil"');
    console.log('4. "Lier avec le num√©ro"');
    console.log(`5. Saisissez: ${connectionCode.substring(0,4)} ${connectionCode.substring(4)}`);
    console.log('\n‚è±Ô∏è  En attente de connexion...\n');
});

client.on('ready', () => {
    isReady = true;
    retryCount = 0;
    lastActivity = Date.now();
    
    console.log('\n' + 'üéâ'.repeat(20));
    console.log('üöÄ BOT WHATSAPP CONNECT√â AVEC SUCC√àS!');
    console.log('üéâ'.repeat(20));
    console.log(`üìû Admin: ${ADMIN_NUMBER}`);
    console.log(`üïí Connect√© √†: ${new Date().toLocaleString('fr-FR')}`);
    console.log('‚úÖ Toutes les fonctionnalit√©s sont op√©rationnelles');
    console.log('üéâ'.repeat(20) + '\n');
    
    // D√©marrer le monitoring de sant√©
    startHealthCheck();
    
    // Nettoyage initial
    setTimeout(() => {
        cleanupExpiredData();
    }, 5000);
});

client.on('authenticated', () => {
    console.log('üîê Authentification r√©ussie');
});

client.on('auth_failure', (msg) => {
    console.error('‚ùå √âchec authentification:', msg);
    handleReconnection('auth_failure');
});

client.on('disconnected', (reason) => {
    console.log('üîå D√©connect√©:', reason);
    isReady = false;
    stopHealthCheck();
    handleReconnection(reason);
});

// Syst√®me de reconnexion automatique
function handleReconnection(reason) {
    if (retryCount >= MAX_RETRY_ATTEMPTS) {
        console.error('‚ùå Nombre max de tentatives atteint. Arr√™t du bot.');
        process.exit(1);
    }
    
    retryCount++;
    console.log(`üîÑ Tentative de reconnexion ${retryCount}/${MAX_RETRY_ATTEMPTS} dans 30s...`);
    
    setTimeout(() => {
        console.log('üöÄ Reconnexion en cours...');
        client.initialize().catch(error => {
            console.error('‚ùå Erreur reconnexion:', error.message);
        });
    }, 30000);
}

// Monitoring de sant√©
function startHealthCheck() {
    healthCheckInterval = setInterval(async () => {
        try {
            if (isReady) {
                const state = await client.getState();
                if (state !== 'CONNECTED') {
                    console.log('‚ö†Ô∏è √âtat inattendu:', state);
                    isReady = false;
                }
            }
            console.log(`üíì Health check: ${isReady ? 'OK' : 'DISCONNECTED'} - ${new Date().toISOString()}`);
        } catch (error) {
            console.error('‚ùå Health check failed:', error.message);
            isReady = false;
        }
    }, HEALTH_CHECK_INTERVAL);
}

function stopHealthCheck() {
    if (healthCheckInterval) {
        clearInterval(healthCheckInterval);
        healthCheckInterval = null;
    }
}

// Nettoyage optimis√©
function cleanupExpiredData() {
    const now = Date.now();
    let cleaned = false;
    
    // Nettoyer codes d'acc√®s expir√©s (24h)
    Object.keys(userData.accessCodes).forEach(phone => {
        if (now - userData.accessCodes[phone].generated > 24 * 60 * 60 * 1000) {
            delete userData.accessCodes[phone];
            cleaned = true;
        }
    });
    
    // Nettoyer utilisateurs expir√©s
    Object.keys(userData.users).forEach(phone => {
        const user = userData.users[phone];
        if (user.authorized && (now - user.authorizedAt) > USAGE_DURATION) {
            user.authorized = false;
            cleaned = true;
        }
    });
    
    if (cleaned) {
        saveData();
        console.log('üßπ Nettoyage des donn√©es expir√©es effectu√©');
    }
}

// Traitement des messages avec gestion d'erreurs renforc√©e
client.on('message', async (message) => {
    if (!isReady) return;
    
    lastActivity = Date.now();
    
    try {
        const contact = await message.getContact();
        const userNumber = contact.id._serialized;
        const messageText = message.body.toLowerCase().trim();
        const chat = await message.getChat();
        
        // Log des messages pour debug (optionnel)
        // console.log(`üì® Message de ${contact.pushname || contact.number}: ${message.body}`);
        
        // V√©rification code de connexion
        if (messageText.startsWith('/connect ')) {
            const inputCode = messageText.split(' ')[1];
            if (verifyConnectionCode(inputCode)) {
                await message.reply('‚úÖ Code de connexion valide! WhatsApp Web est maintenant connect√©.');
                userData.connectionCode = null;
                userData.connectionCodeExpiry = 0;
                saveData();
            } else {
                await message.reply('‚ùå Code de connexion invalide ou expir√©.\nDemandez un nouveau code √† l\'admin.');
            }
            return;
        }
        
        // Commandes administrateur
        if (userNumber === ADMIN_NUMBER) {
            await handleAdminCommands(message, messageText, contact);
            return;
        }
        
        // Activation utilisateur
        if (messageText.startsWith('/activate ')) {
            const code = messageText.split(' ')[1]?.toUpperCase();
            if (!code) {
                await message.reply('‚ùå Usage: /activate [CODE]\n\nExemple: /activate ABC123');
                return;
            }
            
            if (validateAccessCode(userNumber, code)) {
                const expiryDate = new Date(Date.now() + USAGE_DURATION).toLocaleDateString('fr-FR');
                await message.reply(`üéâ *ACC√àS ACTIV√â AVEC SUCC√àS!*\n\n‚úÖ Dur√©e: 30 jours\nüìÖ Expire le: ${expiryDate}\n\nüìã *Commandes disponibles:*\n‚Ä¢ /broadcast [msg] - Diffuser message\n‚Ä¢ /addgroup - Ajouter ce groupe\n‚Ä¢ /mygroups - Voir mes groupes\n‚Ä¢ /status - Mon statut\n‚Ä¢ /help - Aide compl√®te\n\nüöÄ Vous pouvez maintenant utiliser toutes les fonctionnalit√©s!`);
            } else {
                await message.reply('‚ùå *Code invalide*\n\nV√©rifiez:\n‚Ä¢ Le code est correct\n‚Ä¢ Il n\'est pas expir√© (24h max)\n‚Ä¢ Il n\'a pas d√©j√† √©t√© utilis√©\n\nContactez l\'admin pour un nouveau code.');
            }
            return;
        }
        
        // V√©rifier autorisation pour autres commandes
        if (!isUserAuthorized(userNumber)) {
            if (messageText.startsWith('/')) {
                await message.reply('üîí *ACC√àS REQUIS*\n\nVous devez activer votre acc√®s pour utiliser les commandes.\n\nüìû Contactez l\'administrateur pour obtenir un code d\'activation.\n\nüí° Usage: /activate [CODE]');
            }
            return;
        }
        
        // Commandes utilisateur autoris√©
        await handleUserCommands(message, messageText, userNumber, contact, chat);
        
    } catch (error) {
        console.error('‚ùå Erreur traitement message:', error.message);
        
        // Gestion sp√©cifique des erreurs courantes
        if (error.message.includes('Rate limit')) {
            await message.reply('‚è≥ Trop de messages trop rapidement. Patientez quelques secondes.');
        } else if (error.message.includes('Message not found')) {
            console.log('‚ö†Ô∏è Message non trouv√© (probablement supprim√©)');
        } else {
            await message.reply('‚ùå Une erreur est survenue. R√©essayez dans quelques instants.');
        }
    }
});

// Gestion des commandes admin
async function handleAdminCommands(message, messageText, contact) {
    switch (true) {
        case messageText.startsWith('/gencode '):
            const targetNumber = messageText.split(' ')[1];
            if (!targetNumber) {
                await message.reply('‚ùå Usage: /gencode [num√©ro]\n\nExemple: /gencode 237123456789');
                return;
            }
            const formattedNumber = targetNumber.includes('@') ? targetNumber : `${targetNumber}@c.us`;
            const code = generateAccessCode(formattedNumber);
            await message.reply(`‚úÖ *CODE G√âN√âR√â AVEC SUCC√àS*\n\nüë§ Pour: ${targetNumber}\nüîë Code: *${code}*\n‚è∞ Validit√©: 24 heures\nüéØ Usage: Unique\n\nüìã *Instructions pour l'utilisateur:*\nEnvoyer: /activate ${code}\n\nüí° Le code sera automatiquement supprim√© apr√®s usage.`);
            break;
            
        case messageText === '/stats':
            await sendStats(message);
            break;
            
        case messageText === '/newcode':
            const newConnCode = generateConnectionCode();
            await message.reply(`üî¢ *NOUVEAU CODE DE CONNEXION*\n\n*${newConnCode.substring(0,4)} ${newConnCode.substring(4)}*\n\n‚è∞ Valide pendant 10 minutes\nüì± √Ä saisir dans l'application WhatsApp mobile\n\nüìù Instructions:\n1. WhatsApp ‚Üí Appareils li√©s\n2. Lier un appareil\n3. Lier avec le num√©ro\n4. Saisir le code`);
            break;
            
        case messageText === '/cleanup':
            cleanupExpiredData();
            await message.reply('üßπ *Nettoyage termin√©*\n\nDonn√©es expir√©es supprim√©es avec succ√®s.');
            break;
            
        case messageText === '/backup':
            createBackup();
            await message.reply('üíæ *Backup cr√©√©*\n\nSauvegarde des donn√©es effectu√©e.');
            break;
            
        case messageText === '/help':
            await message.reply(`ü§ñ *COMMANDES ADMINISTRATEUR*\n\nüîë /gencode [num√©ro] - G√©n√©rer code d'acc√®s\nüî¢ /newcode - Nouveau code de connexion\nüìä /stats - Statistiques d√©taill√©es\nüßπ /cleanup - Nettoyer donn√©es expir√©es\nüíæ /backup - Cr√©er une sauvegarde\n‚ùì /help - Cette aide\n\nüí° *Conseils:*\n‚Ä¢ G√©n√©rez des codes r√©guli√®rement\n‚Ä¢ Surveillez les stats\n‚Ä¢ Nettoyez p√©riodiquement`);
            break;
    }
}

// Gestion des commandes utilisateur
async function handleUserCommands(message, messageText, userNumber, contact, chat) {
    switch (messageText) {
        case '/status':
            await sendUserStatus(message, userNumber);
            break;
            
        case '/addgroup':
            if (!chat.isGroup) {
                await message.reply('‚ùå *Commande r√©serv√©e aux groupes*\n\nVous devez √™tre dans un groupe pour utiliser cette commande.');
                return;
            }
            
            const groupId = chat.id._serialized;
            userData.groups[groupId] = {
                name: chat.name,
                addedBy: userNumber,
                addedAt: Date.now()
            };
            saveData();
            await message.reply(`‚úÖ *GROUPE AJOUT√â*\n\nüìù Nom: "${chat.name}"\nüìÖ Ajout√© le: ${new Date().toLocaleDateString('fr-FR')}\n\nüí° Vous pouvez maintenant diffuser des messages dans ce groupe avec /broadcast`);
            break;
            
        case '/mygroups':
            await sendUserGroups(message, userNumber);
            break;
            
        case '/help':
            await message.reply(`ü§ñ *COMMANDES UTILISATEUR*\n\nüì¢ /broadcast [message] - Diffuser un message\n‚ûï /addgroup - Ajouter ce groupe √† vos diffusions\nüìã /mygroups - Voir vos groupes\nüìä /status - Votre statut d'acc√®s\n‚ùì /help - Cette aide\n\nüí° *Exemple de diffusion:*\n/broadcast Bonjour √† tous ! üëã\n\n‚ö†Ô∏è *Important:*\nAjoutez d'abord des groupes avec /addgroup`);
            break;
    }
    
    // Commande broadcast
    if (messageText.startsWith('/broadcast ')) {
        await handleBroadcast(message, messageText, userNumber, contact);
    }
}

// Fonctions auxiliaires pour les statistiques et statuts
async function sendStats(message) {
    const activeUsers = Object.values(userData.users).filter(user => 
        user.authorized && (Date.now() - user.authorizedAt) < USAGE_DURATION
    ).length;
    
    const totalUsers = Object.keys(userData.users).length;
    const totalGroups = Object.keys(userData.groups).length;
    const pendingCodes = Object.keys(userData.accessCodes).filter(phone => 
        !userData.accessCodes[phone].used
    ).length;
    
    const uptime = Math.floor((Date.now() - lastActivity) / 60000);
    
    await message.reply(`üìä *STATISTIQUES D√âTAILL√âES*\n\nüë• Utilisateurs actifs: ${activeUsers}\nüë§ Total utilisateurs: ${totalUsers}\nüí¨ Groupes configur√©s: ${totalGroups}\nüîë Codes en attente: ${pendingCodes}\n‚è∞ Derni√®re activit√©: ${uptime}min\nüöÄ Statut: ${isReady ? '‚úÖ Connect√©' : '‚ùå D√©connect√©'}\n\nüìÖ Mis √† jour: ${new Date().toLocaleString('fr-FR')}`);
}

async function sendUserStatus(message, userNumber) {
    const user = userData.users[userNumber];
    const timeLeft = USAGE_DURATION - (Date.now() - user.authorizedAt);
    const daysLeft = Math.ceil(timeLeft / (24 * 60 * 60 * 1000));
    const userGroups = Object.keys(userData.groups).filter(g => 
        userData.groups[g].addedBy === userNumber
    ).length;
    
    await message.reply(`üìä *VOTRE STATUT*\n\n‚úÖ Statut: Autoris√©\n‚è∞ Temps restant: ${daysLeft} jours\nüí¨ Vos groupes: ${userGroups}\nüìÖ Activ√© le: ${new Date(user.authorizedAt).toLocaleDateString('fr-FR')}\nüîÑ Expire le: ${new Date(user.authorizedAt + USAGE_DURATION).toLocaleDateString('fr-FR')}\n\nüí° Contactez l'admin pour renouveler avant expiration.`);
}

async function sendUserGroups(message, userNumber) {
    const myGroups = Object.entries(userData.groups)
        .filter(([_, groupData]) => groupData.addedBy === userNumber)
        .map(([_, groupData]) => `‚Ä¢ ${groupData.name}`)
        .join('\n');
    
    if (myGroups) {
        const groupCount = myGroups.split('\n').length;
        await message.reply(`üìã *VOS GROUPES (${groupCount})*\n\n${myGroups}\n\nüí° Pour ajouter un groupe:\n1. Allez dans le groupe\n2. Tapez /addgroup\n\nüì¢ Pour diffuser: /broadcast [votre message]`);
    } else {
        await message.reply('üì≠ *Aucun groupe configur√©*\n\nüí° Pour ajouter des groupes:\n1. Rejoignez un groupe WhatsApp\n2. Dans le groupe, tapez /addgroup\n3. Le groupe sera ajout√© √† votre liste\n\nüì¢ Vous pourrez ensuite diffuser avec /broadcast');
    }
}

// Gestion de la diffusion
async function handleBroadcast(message, messageText, userNumber, contact) {
    const broadcastMessage = message.body.substring(11);
    if (!broadcastMessage.trim()) {
        await message.reply('‚ùå *Message vide*\n\nUsage: /broadcast [votre message]\n\nExemple:\n/broadcast Bonjour tout le monde ! üëã');
        return;
    }
    
    const userGroups = Object.entries(userData.groups)
        .filter(([_, groupData]) => groupData.addedBy === userNumber);
    
    if (userGroups.length === 0) {
        await message.reply('üì≠ *Aucun groupe disponible*\n\nüí° Pour ajouter des groupes:\n1. Allez dans un groupe\n2. Tapez /addgroup\n3. R√©p√©tez pour chaque groupe souhait√©\n\nüì¢ Vous pourrez ensuite diffuser vos messages !');
        return;
    }
    
    await message.reply(`üöÄ *DIFFUSION EN COURS...*\n\nüìä Groupes cibles: ${userGroups.length}\n‚è≥ Veuillez patienter...`);
    
    let successCount = 0;
    let failCount = 0;
    const failedGroups = [];
    
    for (const [groupId, groupData] of userGroups) {
        try {
            const formattedMessage = `üì¢ *Message Diffus√©*\n\n${broadcastMessage}\n\n_üë§ Envoy√© par: ${contact.pushname || contact.number}_\n_üïí Le: ${new Date().toLocaleString('fr-FR')}_`;
            
            await client.sendMessage(groupId, formattedMessage);
            successCount++;
            
            // Pause pour √©viter le spam
            await new Promise(resolve => setTimeout(resolve, 2000));
            
        } catch (error) {
            console.error(`‚ùå Erreur groupe ${groupData.name}:`, error.message);
            failCount++;
            failedGroups.push(groupData.name);
            
            // Pause m√™me en cas d'erreur
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
    
    let resultMessage = `üìä *DIFFUSION TERMIN√âE*\n\n‚úÖ Succ√®s: ${successCount}/${userGroups.length}`;
    
    if (failCount > 0) {
        resultMessage += `\n‚ùå √âchecs: ${failCount}`;
        if (failedGroups.length > 0) {
            resultMessage += `\n\n‚ö†Ô∏è Groupes en √©chec:\n${failedGroups.map(name => `‚Ä¢ ${name}`).join('\n')}`;
        }
    } else {
        resultMessage += '\nüéâ Tous les messages ont √©t√© envoy√©s !';
    }
    
    resultMessage += `\n\nüïí Termin√© √†: ${new Date().toLocaleTimeString('fr-FR')}`;
    
    await message.reply(resultMessage);
}

// Gestion propre de l'arr√™t
const gracefulShutdown = () => {
    console.log('\nüõë Arr√™t du bot en cours...');
    stopHealthCheck();
    saveData();
    
    if (client) {
        client.destroy().then(() => {
            console.log('‚úÖ Bot arr√™t√© proprement');
            process.exit(0);
        }).catch(() => {
            console.log('‚ö†Ô∏è Arr√™t forc√©');
            process.exit(0);
        });
    } else {
        process.exit(0);
    }
};

// Gestion des signaux syst√®me
process.on('SIGINT', gracefulShutdown);
process.on('SIGTERM', gracefulShutdown);
process.on('uncaughtException', (error) => {
    console.error('‚ùå Exception non g√©r√©e:', error.message);
    createBackup();
    gracefulShutdown();
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Promesse rejet√©e non g√©r√©e:', reason);
});

// Initialisation du bot
console.log('\n' + 'üöÄ'.repeat(20));
console.log('D√âMARRAGE BOT WHATSAPP AVANC√â');
console.log('üöÄ'.repeat(20));
console.log('üìç Version: Stable & Optimis√©e');
console.log('üåê Environnement: Render.com Ready');
console.log('üîß Fonctionnalit√©s: Compl√®tes');
console.log('üöÄ'.repeat(20) + '\n');

// Chargement des donn√©es
if (!loadData()) {
    console.error('‚ùå Impossible de charger les donn√©es. Arr√™t du bot.');
    process.exit(1);
}

// Nettoyage p√©riodique (toutes les heures)
setInterval(() => {
    if (Date.now() - lastActivity > 30 * 60 * 1000) { // Si inactif depuis 30min
        cleanupExpiredData();
    }
}, 60 * 60 * 1000);

// D√©marrage du client
console.log('üîÑ Initialisation du client WhatsApp...');
client.initialize().catch(error => {
    console.error('‚ùå Erreur initialisation:', error.message);
    console.log('üîÑ Nouvelle tentative dans 10 secondes...');
    setTimeout(() => {
        process.exit(1);
    }, 10000);
});

console.log('‚úÖ Bot WhatsApp d√©marr√© avec succ√®s!');
console.log('üìû En attente de connexion...\n');
