const { Client, LocalAuth } = require('whatsapp-web.js');
const QRCode = require('qrcode');
const express = require('express');
const { google } = require('googleapis');

// Configuration centralis√©e
const CONFIG = {
    ADMIN_NUMBER: '237651104356@c.us',
    PORT: process.env.PORT || 3000,
    USAGE_DAYS: 30,
    CODE_EXPIRY_HOURS: 24,
    QR_TIMEOUT: 120000,
    // Configuration Google Drive
    GDRIVE: {
        PARENT_FOLDER_ID: process.env.GDRIVE_FOLDER_ID || null, // ID du dossier parent sur Google Drive
        FILES: {
            USERS: 'users.json',
            CODES: 'codes.json',
            GROUPS: 'groups.json'
        }
    }
};

// √âtat global simplifi√©
const state = {
    ready: false,
    qr: null,
    client: null,
    server: null,
    // Cache en m√©moire pour performance
    cache: {
        users: new Map(),
        codes: new Map(),
        groups: new Map()
    },
    // Google Drive
    drive: null,
    driveFiles: {
        users: null,
        codes: null,
        groups: null
    }
};

// Initialisation Google Drive
async function initGoogleDrive() {
    try {
        // Cr√©er les credentials depuis les variables d'environnement
        const credentials = {
            type: process.env.GOOGLE_TYPE,
            project_id: process.env.GOOGLE_PROJECT_ID,
            private_key_id: process.env.GOOGLE_PRIVATE_KEY_ID,
            private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
            client_email: process.env.GOOGLE_CLIENT_EMAIL,
            client_id: process.env.GOOGLE_CLIENT_ID,
            auth_uri: process.env.GOOGLE_AUTH_URI,
            token_uri: process.env.GOOGLE_TOKEN_URI,
            auth_provider_x509_cert_url: process.env.GOOGLE_AUTH_PROVIDER_X509_CERT_URL,
            client_x509_cert_url: process.env.GOOGLE_CLIENT_X509_CERT_URL
        };

        // Authentification avec Google
        const auth = new google.auth.GoogleAuth({
            credentials,
            scopes: ['https://www.googleapis.com/auth/drive.file']
        });

        state.drive = google.drive({ version: 'v3', auth });

        // V√©rifier les fichiers existants ou les cr√©er
        await initDriveFiles();

        console.log('‚úÖ Google Drive initialis√©');
        return true;
    } catch (error) {
        console.error('‚ùå Erreur Google Drive:', error.message);
        return false;
    }
}

// Initialiser les fichiers sur Google Drive
async function initDriveFiles() {
    try {
        for (const [key, fileName] of Object.entries(CONFIG.GDRIVE.FILES)) {
            // Chercher le fichier existant
            const response = await state.drive.files.list({
                q: `name='${fileName}'${CONFIG.GDRIVE.PARENT_FOLDER_ID ? ` and parents in '${CONFIG.GDRIVE.PARENT_FOLDER_ID}'` : ''}`,
                fields: 'files(id, name)'
            });

            if (response.data.files.length > 0) {
                // Fichier trouv√©
                state.driveFiles[key] = response.data.files[0].id;
                console.log(`üìÑ Trouv√©: ${fileName} (${state.driveFiles[key]})`);
            } else {
                // Cr√©er le fichier
                const fileMetadata = {
                    name: fileName,
                    parents: CONFIG.GDRIVE.PARENT_FOLDER_ID ? [CONFIG.GDRIVE.PARENT_FOLDER_ID] : undefined
                };

                const media = {
                    mimeType: 'application/json',
                    body: '{}'
                };

                const file = await state.drive.files.create({
                    resource: fileMetadata,
                    media: media,
                    fields: 'id'
                });

                state.driveFiles[key] = file.data.id;
                console.log(`üìÑ Cr√©√©: ${fileName} (${state.driveFiles[key]})`);
            }
        }

        // Charger les donn√©es en cache
        await loadCache();

        // Nettoyage automatique au d√©marrage
        await cleanupExpiredData();

        return true;
    } catch (error) {
        console.error('‚ùå Erreur init fichiers Drive:', error.message);
        return false;
    }
}

// Charger toutes les donn√©es depuis Google Drive
async function loadCache() {
    try {
        const promises = [];
        
        for (const [key, fileId] of Object.entries(state.driveFiles)) {
            promises.push(
                state.drive.files.get({
                    fileId: fileId,
                    alt: 'media'
                }).then(response => ({ key, data: response.data }))
            );
        }

        const results = await Promise.all(promises);
        
        for (const { key, data } of results) {
            const parsedData = typeof data === 'string' ? JSON.parse(data || '{}') : (data || {});
            state.cache[key] = new Map(Object.entries(parsedData));
        }

        console.log(`üìä Cache charg√© depuis Drive: ${state.cache.users.size} users, ${state.cache.codes.size} codes, ${state.cache.groups.size} groups`);
    } catch (error) {
        console.error('‚ùå Erreur chargement cache Drive:', error.message);
    }
}

// Sauvegarder les donn√©es sur Google Drive
async function saveData(type) {
    try {
        if (!state.driveFiles[type]) {
            console.error(`‚ùå ID fichier ${type} manquant`);
            return false;
        }

        const data = Object.fromEntries(state.cache[type]);
        const jsonData = JSON.stringify(data, null, 2);

        await state.drive.files.update({
            fileId: state.driveFiles[type],
            media: {
                mimeType: 'application/json',
                body: jsonData
            }
        });

        console.log(`üíæ ${type} sauvegard√© sur Drive`);
        return true;
    } catch (error) {
        console.error(`‚ùå Erreur sauvegarde ${type} sur Drive:`, error.message);
        return false;
    }
}

// Nettoyage des donn√©es expir√©es
async function cleanupExpiredData() {
    try {
        const now = new Date();
        let cleaned = 0;
        
        // Nettoyer les codes expir√©s
        for (const [phone, codeData] of state.cache.codes) {
            if (new Date(codeData.expiresAt) < now) {
                state.cache.codes.delete(phone);
                cleaned++;
            }
        }
        
        // D√©sactiver les utilisateurs expir√©s
        for (const [phone, userData] of state.cache.users) {
            if (userData.active && userData.activatedAt) {
                const daysSince = (now.getTime() - new Date(userData.activatedAt).getTime()) / 86400000;
                if (daysSince > CONFIG.USAGE_DAYS) {
                    userData.active = false;
                    state.cache.users.set(phone, userData);
                    cleaned++;
                }
            }
        }
        
        if (cleaned > 0) {
            await Promise.all([
                saveData('codes'),
                saveData('users')
            ]);
            console.log(`üßπ ${cleaned} √©l√©ments nettoy√©s`);
        }
    } catch (error) {
        console.error('‚ùå Erreur nettoyage:', error.message);
    }
}

// G√©n√©rateur de code optimis√©
function generateCode() {
    const chars = 'ABCDEFGHJKLMNPQRTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 8; i++) {
        if (i === 4) code += '-';
        code += chars[Math.floor(Math.random() * chars.length)];
    }
    return code;
}

// Fonctions base de donn√©es Google Drive
const db = {
    async createCode(phone) {
        const code = generateCode();
        const expiresAt = new Date(Date.now() + CONFIG.CODE_EXPIRY_HOURS * 3600000);
        
        const codeData = {
            phone,
            code,
            used: false,
            expiresAt: expiresAt.toISOString(),
            createdAt: new Date().toISOString()
        };
        
        state.cache.codes.set(phone, codeData);
        await saveData('codes');
        
        return code;
    },

    async validateCode(phone, inputCode) {
        try {
            const codeData = state.cache.codes.get(phone);
            
            if (!codeData || codeData.used || new Date(codeData.expiresAt) < new Date()) {
                return false;
            }
            
            if (codeData.code.replace('-', '') !== inputCode.replace(/[-\s]/g, '').toUpperCase()) {
                return false;
            }
            
            // Marquer le code comme utilis√©
            codeData.used = true;
            state.cache.codes.set(phone, codeData);
            
            // Activer l'utilisateur
            const userData = state.cache.users.get(phone) || {};
            userData.phone = phone;
            userData.active = true;
            userData.activatedAt = new Date().toISOString();
            userData.createdAt = userData.createdAt || new Date().toISOString();
            
            state.cache.users.set(phone, userData);
            
            // Sauvegarder les deux fichiers
            await Promise.all([
                saveData('codes'),
                saveData('users')
            ]);
            
            return true;
        } catch (error) {
            console.error('‚ùå Erreur validation:', error.message);
            return false;
        }
    },

    async isAuthorized(phone) {
        try {
            const userData = state.cache.users.get(phone);
            
            if (!userData || !userData.active) return false;
            
            const daysSince = (Date.now() - new Date(userData.activatedAt).getTime()) / 86400000;
            
            if (daysSince > CONFIG.USAGE_DAYS) {
                userData.active = false;
                state.cache.users.set(phone, userData);
                await saveData('users');
                return false;
            }
            
            return true;
        } catch (error) {
            console.error('‚ùå Erreur autorisation:', error.message);
            return false;
        }
    },

    async addGroup(groupId, name, addedBy) {
        try {
            if (state.cache.groups.has(groupId)) {
                return false; // D√©j√† existe
            }
            
            const groupData = {
                groupId,
                name,
                addedBy,
                addedAt: new Date().toISOString()
            };
            
            state.cache.groups.set(groupId, groupData);
            await saveData('groups');
            
            return true;
        } catch (error) {
            console.error('‚ùå Erreur ajout groupe:', error.message);
            return false;
        }
    },

    async getUserGroups(phone) {
        try {
            const userGroups = [];
            
            for (const [groupId, groupData] of state.cache.groups) {
                if (groupData.addedBy === phone) {
                    userGroups.push({
                        group_id: groupData.groupId,
                        name: groupData.name
                    });
                }
            }
            
            return userGroups;
        } catch (error) {
            console.error('‚ùå Erreur groupes utilisateur:', error.message);
            return [];
        }
    },

    async getStats() {
        try {
            let activeUsers = 0;
            let usedCodes = 0;
            
            // Compter les utilisateurs actifs
            for (const [phone, userData] of state.cache.users) {
                if (userData.active) activeUsers++;
            }
            
            // Compter les codes utilis√©s
            for (const [phone, codeData] of state.cache.codes) {
                if (codeData.used) usedCodes++;
            }
            
            return {
                total_users: state.cache.users.size,
                active_users: activeUsers,
                total_codes: state.cache.codes.size,
                used_codes: usedCodes,
                total_groups: state.cache.groups.size
            };
        } catch (error) {
            console.error('‚ùå Erreur stats:', error.message);
            return {
                total_users: 0,
                active_users: 0,
                total_codes: 0,
                used_codes: 0,
                total_groups: 0
            };
        }
    }
};

// Interface web minimaliste
const app = express();
app.use(express.json({ limit: '1mb' }));

app.get('/', (req, res) => {
    const html = state.ready ? 
        `<h1 style="color:green">‚úÖ Bot En Ligne</h1><p>üïí ${new Date().toLocaleString()}</p><p>‚òÅÔ∏è Google Drive</p>` :
        state.qr ? 
        `<h1>üì± Scanner QR Code</h1><img src="data:image/png;base64,${state.qr}"><script>setTimeout(()=>location.reload(),30000)</script>` :
        `<h1>üîÑ Initialisation...</h1><script>setTimeout(()=>location.reload(),10000)</script>`;
    
    res.send(`<!DOCTYPE html><html><head><title>WhatsApp Bot</title><meta name="viewport" content="width=device-width,initial-scale=1"><style>body{font-family:Arial;text-align:center;background:#25D366;color:white;padding:50px}img{background:white;padding:20px;border-radius:10px}</style></head><body>${html}</body></html>`);
});

app.get('/health', (req, res) => {
    res.json({ 
        status: state.ready ? 'online' : 'offline',
        database: 'google-drive',
        uptime: Math.floor(process.uptime()),
        timestamp: new Date().toISOString(),
        cache_size: {
            users: state.cache.users.size,
            codes: state.cache.codes.size,
            groups: state.cache.groups.size
        },
        drive_files: state.driveFiles
    });
});

// Initialisation client WhatsApp
async function initClient() {
    state.client = new Client({
        authStrategy: new LocalAuth({ clientId: 'whatsapp-bot' }),
        puppeteer: {
            headless: true,
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-gpu',
                '--single-process',
                '--no-zygote'
            ]
        }
    });

    // √âv√©nements
    state.client.on('qr', async (qr) => {
        console.log('üì± QR Code g√©n√©r√©');
        state.qr = (await QRCode.toDataURL(qr, { width: 400 })).split(',')[1];
        setTimeout(() => { if (!state.ready) state.qr = null; }, CONFIG.QR_TIMEOUT);
    });

    state.client.on('authenticated', () => {
        console.log('üîê Authentifi√©');
        state.qr = null;
    });

    state.client.on('ready', async () => {
        state.ready = true;
        state.qr = null;
        console.log('üéâ BOT PR√äT!');
        
        setTimeout(async () => {
            try {
                await state.client.sendMessage(CONFIG.ADMIN_NUMBER, 
                    `üéâ *BOT EN LIGNE*\n‚òÅÔ∏è Google Drive connect√©\nüïí ${new Date().toLocaleString()}`);
            } catch (e) {}
        }, 3000);
    });

    state.client.on('disconnected', () => {
        console.log('üîå D√©connect√©');
        state.ready = false;
    });

    // Traitement des messages
    state.client.on('message', async (msg) => {
        if (!state.ready || !msg.body || msg.type !== 'chat' || !msg.body.startsWith('/')) return;
        
        try {
            const contact = await msg.getContact();
            if (!contact || contact.isMe) return;

            const phone = contact.id._serialized;
            const text = msg.body.trim();
            const cmd = text.toLowerCase();

            console.log(`üì® ${phone.replace('@c.us', '')}: ${cmd.substring(0, 30)}...`);

            // Commandes admin
            if (phone === CONFIG.ADMIN_NUMBER) {
                if (cmd.startsWith('/gencode ')) {
                    const number = text.substring(9).trim();
                    if (!number) return msg.reply('‚ùå Usage: /gencode [num√©ro]');
                    
                    const targetPhone = number.includes('@') ? number : `${number}@c.us`;
                    const code = await db.createCode(targetPhone);
                    await msg.reply(`‚úÖ *CODE G√âN√âR√â*\nüë§ ${number}\nüîë ${code}\n‚è∞ 24h\nüìù /activate ${code}`);
                    
                } else if (cmd === '/stats') {
                    const stats = await db.getStats();
                    await msg.reply(`üìä *STATS DRIVE*\nüë• Total: ${stats.total_users}\n‚úÖ Actifs: ${stats.active_users}\nüîë Codes: ${stats.total_codes}/${stats.used_codes}\nüì¢ Groupes: ${stats.total_groups}`);
                    
                } else if (cmd === '/backup') {
                    // Sauvegarder tout
                    await Promise.all([
                        saveData('users'),
                        saveData('codes'),
                        saveData('groups')
                    ]);
                    await msg.reply('‚úÖ Backup Drive effectu√©!');
                    
                } else if (cmd === '/help') {
                    await msg.reply('ü§ñ *ADMIN*\n‚Ä¢ /gencode [num] - Cr√©er code\n‚Ä¢ /stats - Statistiques\n‚Ä¢ /backup - Sauvegarder\n‚Ä¢ /help - Aide\n\n‚òÅÔ∏è Google Drive');
                }
                return;
            }

            // Activation
            if (cmd.startsWith('/activate ')) {
                const code = text.substring(10).trim();
                if (!code) return msg.reply('‚ùå Usage: /activate XXXX-XXXX');
                
                if (await db.validateCode(phone, code)) {
                    await msg.reply(`üéâ *ACTIV√â!* Expire dans ${CONFIG.USAGE_DAYS} jours\n\nüìã *Commandes:*\n‚Ä¢ /broadcast [msg] - Diffuser\n‚Ä¢ /addgroup - Ajouter groupe\n‚Ä¢ /status - Mon statut\n‚Ä¢ /help - Aide`);
                } else {
                    await msg.reply('‚ùå Code invalide ou expir√©');
                }
                return;
            }

            // V√©rifier autorisation
            if (!(await db.isAuthorized(phone))) {
                return msg.reply(`üîí *Acc√®s requis*\nüìû Contact: ${CONFIG.ADMIN_NUMBER.replace('@c.us', '')}\nüîë /activate VOTRE-CODE`);
            }

            // Commandes utilisateur
            if (cmd === '/status') {
                const userData = state.cache.users.get(phone);
                const remaining = Math.ceil(CONFIG.USAGE_DAYS - (Date.now() - new Date(userData.activatedAt).getTime()) / 86400000);
                const groups = await db.getUserGroups(phone);
                await msg.reply(`üìä *STATUT*\nüü¢ Actif\nüìÖ ${remaining} jours restants\nüì¢ ${groups.length} groupes\n‚òÅÔ∏è Google Drive`);
                
            } else if (cmd === '/addgroup') {
                const chat = await msg.getChat();
                if (!chat.isGroup) return msg.reply('‚ùå Uniquement dans les groupes!');
                
                const added = await db.addGroup(chat.id._serialized, chat.name, phone);
                await msg.reply(added ? 
                    `‚úÖ *Groupe ajout√©!*\nüì¢ ${chat.name}\nüí° /broadcast [message] pour diffuser` :
                    `‚ÑπÔ∏è Groupe d√©j√† enregistr√©: ${chat.name}`);
                    
            } else if (cmd.startsWith('/broadcast ')) {
                const message = text.substring(11).trim();
                if (!message) return msg.reply('‚ùå Usage: /broadcast [message]');
                
                const groups = await db.getUserGroups(phone);
                if (!groups.length) return msg.reply('‚ùå Aucun groupe! Utilisez /addgroup d\'abord');
                
                await msg.reply(`üöÄ Diffusion vers ${groups.length} groupe(s)...`);
                
                let success = 0;
                const senderName = contact.pushname || 'Utilisateur';
                
                for (const group of groups) {
                    try {
                        const fullMsg = `üì¢ *DIFFUSION*\nüë§ ${senderName}\nüïí ${new Date().toLocaleString()}\n\n${message}`;
                        await state.client.sendMessage(group.group_id, fullMsg);
                        success++;
                        await new Promise(r => setTimeout(r, 2000));
                    } catch (e) {}
                }
                
                await msg.reply(`üìä *R√âSULTAT*\n‚úÖ ${success}/${groups.length} groupes\n${success > 0 ? 'üéâ Diffus√©!' : '‚ùå √âchec'}`);
                
            } else if (cmd === '/help') {
                const groups = await db.getUserGroups(phone);
                await msg.reply(`ü§ñ *COMMANDES*\n‚Ä¢ /broadcast [msg] - Diffuser\n‚Ä¢ /addgroup - Ajouter groupe\n‚Ä¢ /status - Mon statut\n‚Ä¢ /help - Aide\n\nüìä ${groups.length} groupe(s)\n‚òÅÔ∏è Google Drive`);
            }
            
        } catch (error) {
            console.error('‚ùå Erreur message:', error.message);
            try { await msg.reply('‚ùå Erreur temporaire'); } catch (e) {}
        }
    });

    await state.client.initialize();
}

// Nettoyage et sauvegarde p√©riodiques
setInterval(async () => {
    try {
        await cleanupExpiredData();
        
        // Sauvegarde pr√©ventive toutes les heures
        await Promise.all([
            saveData('users'),
            saveData('codes'),
            saveData('groups')
        ]);
        
        console.log('üíæ Sauvegarde p√©riodique Google Drive effectu√©e');
    } catch (e) {
        console.error('‚ùå Erreur sauvegarde p√©riodique:', e.message);
    }
}, 3600000); // 1h

// Keep-alive pour Render
setInterval(() => {
    console.log(`üíó Uptime: ${Math.floor(process.uptime())}s - ${state.ready ? 'ONLINE' : 'OFFLINE'} - ‚òÅÔ∏è Drive (${state.cache.users.size}/${state.cache.codes.size}/${state.cache.groups.size})`);
}, 300000);

// D√©marrage
async function start() {
    console.log('üöÄ D√âMARRAGE BOT WHATSAPP');
    console.log('‚òÅÔ∏è Base: Google Drive (100% GRATUIT)');
    console.log('üåê H√©bergeur: Render');
    
    if (!(await initGoogleDrive())) {
        console.error('‚ùå √âchec initialisation Google Drive');
        process.exit(1);
    }
    
    state.server = app.listen(CONFIG.PORT, '0.0.0.0', () => {
        console.log(`üåê Serveur port ${CONFIG.PORT}`);
    });
    
    await initClient();
}

// Arr√™t propre avec sauvegarde
async function shutdown() {
    console.log('üõë Arr√™t en cours...');
    
    // Sauvegarder toutes les donn√©es avant l'arr√™t
    try {
        await Promise.all([
            saveData('users'),
            saveData('codes'),
            saveData('groups')
        ]);
        console.log('üíæ Donn√©es sauvegard√©es sur Google Drive');
    } catch (e) {
        console.error('‚ùå Erreur sauvegarde finale:', e.message);
    }
    
    if (state.client) {
        try {
            await state.client.sendMessage(CONFIG.ADMIN_NUMBER, 'üõë Bot arr√™t√© - donn√©es sauvegard√©es sur Drive');
        } catch (e) {}
        await state.client.destroy();
    }
    
    if (state.server) state.server.close();
    
    console.log('‚úÖ Arr√™t termin√©');
    process.exit(0);
}

process.on('SIGTERM', shutdown);
process.on('SIGINT', shutdown);

// Gestion erreurs
process.on('uncaughtException', (error) => {
    console.error('‚ùå Exception:', error.message);
});

process.on('unhandledRejection', (reason) => {
    console.error('‚ùå Promise rejet√©e:', reason);
});

// Point d'entr√©e
if (require.main === module) {
    start().catch(error => {
        console.error('‚ùå ERREUR D√âMARRAGE:', error.message);
        process.exit(1);
    });
}

module.exports = { start, CONFIG, state };
