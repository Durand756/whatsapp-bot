const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const fs = require('fs');
const path = require('path');

// Configuration
const ADMIN_NUMBER = '237679199601@c.us'; // Remplacer par le num√©ro admin
const DATA_FILE = path.join(__dirname, 'users_data.json');
const USAGE_DURATION = 30 * 24 * 60 * 60 * 1000; // 30 jours
const CONNECTION_CODE_DURATION = 10 * 60 * 1000; // 10 minutes pour le code de connexion

// Variables globales pour la performance
let userData = {
    users: {},
    accessCodes: {},
    groups: {},
    connectionCode: null,
    connectionCodeExpiry: 0
};

let isReady = false;
let lastActivity = Date.now();

// Charger les donn√©es avec gestion d'erreur am√©lior√©e
function loadData() {
    try {
        if (fs.existsSync(DATA_FILE)) {
            const data = fs.readFileSync(DATA_FILE, 'utf8');
            const parsed = JSON.parse(data);
            userData = { ...userData, ...parsed };
            console.log('‚úÖ Donn√©es charg√©es avec succ√®s');
        }
    } catch (error) {
        console.error('‚ùå Erreur chargement donn√©es:', error.message);
        // Cr√©er une sauvegarde d'urgence
        saveDataBackup();
    }
}

// Sauvegarder avec backup
function saveData() {
    try {
        // Nettoyer les donn√©es avant sauvegarde
        cleanupBeforeSave();
        
        fs.writeFileSync(DATA_FILE, JSON.stringify(userData, null, 2));
        console.log('üíæ Donn√©es sauvegard√©es');
    } catch (error) {
        console.error('‚ùå Erreur sauvegarde:', error.message);
    }
}

// Sauvegarde d'urgence
function saveDataBackup() {
    try {
        const backupFile = path.join(__dirname, `backup_${Date.now()}.json`);
        fs.writeFileSync(backupFile, JSON.stringify(userData, null, 2));
        console.log(`üîÑ Backup cr√©√©: ${backupFile}`);
    } catch (error) {
        console.error('‚ùå Erreur backup:', error.message);
    }
}

// Nettoyer avant sauvegarde pour optimiser
function cleanupBeforeSave() {
    const now = Date.now();
    
    // Supprimer les codes de connexion expir√©s
    if (userData.connectionCodeExpiry && now > userData.connectionCodeExpiry) {
        userData.connectionCode = null;
        userData.connectionCodeExpiry = 0;
    }
}

// G√©n√©rer un code de connexion √† 8 chiffres
function generateConnectionCode() {
    const code = Math.floor(10000000 + Math.random() * 90000000).toString();
    userData.connectionCode = code;
    userData.connectionCodeExpiry = Date.now() + CONNECTION_CODE_DURATION;
    saveData();
    
    console.log(`üîë Code de connexion g√©n√©r√©: ${code.substring(0,3)} ${code.substring(3)}`);
    return code;
}

// V√©rifier le code de connexion
function verifyConnectionCode(inputCode) {
    const now = Date.now();
    
    if (!userData.connectionCode || now > userData.connectionCodeExpiry) {
        return false;
    }
    
    return userData.connectionCode === inputCode.replace(/\s/g, '');
}

// G√©n√©rer un code d'acc√®s utilisateur
function generateAccessCode(phoneNumber) {
    const code = Math.random().toString(36).substring(2, 8).toUpperCase();
    userData.accessCodes[phoneNumber] = {
        code: code,
        generated: Date.now(),
        used: false
    };
    saveData();
    return code;
}

// V√©rifier autorisation utilisateur
function isUserAuthorized(phoneNumber) {
    const user = userData.users[phoneNumber];
    if (!user || !user.authorized) return false;
    
    const now = Date.now();
    const isValid = (now - user.authorizedAt) < USAGE_DURATION;
    
    if (!isValid && user.authorized) {
        user.authorized = false;
        saveData();
    }
    
    return isValid;
}

// Valider code d'acc√®s
function validateAccessCode(phoneNumber, code) {
    const accessData = userData.accessCodes[phoneNumber];
    if (!accessData || accessData.used || accessData.code !== code.toUpperCase()) {
        return false;
    }
    
    accessData.used = true;
    userData.users[phoneNumber] = {
        authorized: true,
        authorizedAt: Date.now(),
        phoneNumber: phoneNumber
    };
    
    saveData();
    return true;
}

// Nettoyage optimis√© des donn√©es expir√©es
function cleanupExpiredData() {
    const now = Date.now();
    const codeExpiry = 24 * 60 * 60 * 1000;
    let cleaned = false;
    
    // Nettoyer codes d'acc√®s expir√©s
    for (const phone in userData.accessCodes) {
        if (now - userData.accessCodes[phone].generated > codeExpiry) {
            delete userData.accessCodes[phone];
            cleaned = true;
        }
    }
    
    // Nettoyer utilisateurs expir√©s
    for (const phone in userData.users) {
        const user = userData.users[phone];
        if (user.authorized && (now - user.authorizedAt) > USAGE_DURATION) {
            user.authorized = false;
            cleaned = true;
        }
    }
    
    if (cleaned) {
        saveData();
        console.log('üßπ Nettoyage des donn√©es expir√©es effectu√©');
    }
}

// Configuration client optimis√©e pour Render
const client = new Client({
    authStrategy: new LocalAuth({
        clientId: "whatsapp-bot-render",
        dataPath: './auth_data'
    }),
    puppeteer: {
        headless: true,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--disable-web-security',
            '--disable-features=VizDisplayCompositor',
            '--no-first-run',
            '--no-zygote',
            '--single-process',
            '--disable-gpu',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-renderer-backgrounding'
        ],
        timeout: 60000
    }
});

// Gestion QR Code avec code de connexion
client.on('qr', (qr) => {
    console.log('\nüîó === CONNEXION WHATSAPP ===');
    console.log('Vous avez 2 options pour vous connecter:');
    console.log('\nüì± OPTION 1 - Scanner le QR Code:');
    qrcode.generate(qr, { small: true });
    
    console.log('\nüî¢ OPTION 2 - Code de connexion:');
    const connectionCode = generateConnectionCode();
    console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
    console.log(`‚îÇ  Saisissez ce code dans votre mobile:  ‚îÇ`);
    console.log(`‚îÇ                                         ‚îÇ`);
    console.log(`‚îÇ           ${connectionCode.substring(0,3)} ${connectionCode.substring(3)}              ‚îÇ`);
    console.log(`‚îÇ                                         ‚îÇ`);
    console.log(`‚îÇ  (Code valide pendant 10 minutes)      ‚îÇ`);
    console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
    console.log('\n√âtapes pour le code:');
    console.log('1. Ouvrez WhatsApp sur votre t√©l√©phone');
    console.log('2. Allez dans Param√®tres > Appareils li√©s');
    console.log('3. Cliquez "Lier un appareil"');
    console.log('4. Choisissez "Lier avec le num√©ro de t√©l√©phone"');
    console.log(`5. Saisissez: ${connectionCode.substring(0,3)} ${connectionCode.substring(3)}`);
    console.log('\n‚è±Ô∏è  En attente de connexion...\n');
});

// Connexion r√©ussie
client.on('ready', () => {
    isReady = true;
    console.log('\nüéâ === BOT CONNECT√â AVEC SUCC√àS ===');
    console.log(`üìû Admin: ${ADMIN_NUMBER}`);
    console.log(`üïí Heure: ${new Date().toLocaleString('fr-FR')}`);
    console.log('‚úÖ Le bot est maintenant op√©rationnel!\n');
    
    // Nettoyage initial
    cleanupExpiredData();
    
    // Nettoyage p√©riodique optimis√©
    setInterval(() => {
        if (Date.now() - lastActivity > 30 * 60 * 1000) { // 30 min d'inactivit√©
            cleanupExpiredData();
        }
    }, 60 * 60 * 1000); // Toutes les heures
});

// Traitement des messages optimis√©
client.on('message', async (message) => {
    if (!isReady) return;
    
    lastActivity = Date.now();
    
    try {
        const contact = await message.getContact();
        const userNumber = contact.id._serialized;
        const messageText = message.body.toLowerCase().trim();
        const chat = await message.getChat();
        
        // V√©rifier code de connexion d'abord
        if (messageText.startsWith('/connect ')) {
            const inputCode = messageText.split(' ')[1];
            if (verifyConnectionCode(inputCode)) {
                await message.reply('‚úÖ Code de connexion valide! Vous pouvez maintenant utiliser WhatsApp Web.');
                userData.connectionCode = null; // Invalider apr√®s usage
                saveData();
            } else {
                await message.reply('‚ùå Code de connexion invalide ou expir√©.');
            }
            return;
        }
        
        // Commandes admin optimis√©es
        if (userNumber === ADMIN_NUMBER) {
            switch (true) {
                case messageText.startsWith('/gencode '):
                    const targetNumber = messageText.split(' ')[1];
                    if (!targetNumber) {
                        await message.reply('‚ùå Usage: /gencode [num√©ro]');
                        return;
                    }
                    const formattedNumber = targetNumber.includes('@') ? targetNumber : `${targetNumber}@c.us`;
                    const code = generateAccessCode(formattedNumber);
                    await message.reply(`‚úÖ *Code g√©n√©r√© pour ${targetNumber}*\n\nüîë Code: *${code}*\n‚è∞ Valide: 24h\nüéØ Usage: Unique\n\n_L'utilisateur doit envoyer: /activate ${code}_`);
                    break;
                    
                case messageText === '/stats':
                    const activeUsers = Object.values(userData.users).filter(user => 
                        user.authorized && (Date.now() - user.authorizedAt) < USAGE_DURATION
                    ).length;
                    const totalGroups = Object.keys(userData.groups).length;
                    const pendingCodes = Object.keys(userData.accessCodes).filter(phone => 
                        !userData.accessCodes[phone].used
                    ).length;
                    
                    await message.reply(`üìä *Statistiques Bot*\n\nüë• Actifs: ${activeUsers}\nüí¨ Groupes: ${totalGroups}\nüîë Codes: ${pendingCodes}\nüïí Uptime: ${Math.floor((Date.now() - lastActivity) / 60000)}min`);
                    break;
                    
                case messageText === '/newcode':
                    const newConnCode = generateConnectionCode();
                    await message.reply(`üî¢ *Nouveau Code de Connexion*\n\n*${newConnCode.substring(0,3)} ${newConnCode.substring(3)}*\n\n‚è∞ Valide 10 minutes\nüì± √Ä saisir dans WhatsApp mobile`);
                    break;
                    
                case messageText === '/cleanup':
                    cleanupExpiredData();
                    await message.reply('üßπ Nettoyage des donn√©es expir√©es termin√©.');
                    break;
                    
                case messageText === '/help':
                    await message.reply(`ü§ñ *Commandes Admin*\n\n/gencode [num] - G√©n√©rer code acc√®s\n/newcode - Nouveau code connexion\n/stats - Statistiques\n/cleanup - Nettoyer donn√©es\n/help - Cette aide`);
                    break;
            }
            return;
        }
        
        // Activation utilisateur
        if (messageText.startsWith('/activate ')) {
            const code = messageText.split(' ')[1]?.toUpperCase();
            if (!code) {
                await message.reply('‚ùå Usage: /activate [CODE]');
                return;
            }
            
            if (validateAccessCode(userNumber, code)) {
                await message.reply(`üéâ *Acc√®s Activ√©!*\n\n‚úÖ Dur√©e: 30 jours\nüìÖ Expire: ${new Date(Date.now() + USAGE_DURATION).toLocaleDateString('fr-FR')}\n\nüìñ *Commandes:*\n/broadcast [msg] - Diffuser\n/addgroup - Ajouter groupe\n/mygroups - Mes groupes\n/status - Mon statut\n/help - Aide`);
            } else {
                await message.reply('‚ùå Code invalide, expir√© ou d√©j√† utilis√©.');
            }
            return;
        }
        
        // V√©rifier autorisation pour autres commandes
        if (!isUserAuthorized(userNumber)) {
            if (messageText.startsWith('/')) {
                await message.reply('üîí *Acc√®s Requis*\n\nContactez l\'admin pour un code d\'acc√®s.\nUsage: /activate [CODE]');
            }
            return;
        }
        
        // Commandes utilisateur autoris√©
        switch (messageText) {
            case '/status':
                const user = userData.users[userNumber];
                const timeLeft = USAGE_DURATION - (Date.now() - user.authorizedAt);
                const daysLeft = Math.ceil(timeLeft / (24 * 60 * 60 * 1000));
                const userGroups = Object.keys(userData.groups).filter(g => 
                    userData.groups[g].addedBy === userNumber
                ).length;
                
                await message.reply(`üìä *Votre Statut*\n\n‚úÖ Autoris√©\n‚è∞ ${daysLeft} jours restants\nüí¨ ${userGroups} groupes\nüì± Actif depuis: ${new Date(user.authorizedAt).toLocaleDateString('fr-FR')}`);
                break;
                
            case '/addgroup':
                if (!chat.isGroup) {
                    await message.reply('‚ùå Commande r√©serv√©e aux groupes.');
                    return;
                }
                
                const groupId = chat.id._serialized;
                userData.groups[groupId] = {
                    name: chat.name,
                    addedBy: userNumber,
                    addedAt: Date.now()
                };
                saveData();
                await message.reply(`‚úÖ Groupe *"${chat.name}"* ajout√© √† votre liste de diffusion.`);
                break;
                
            case '/mygroups':
                const myGroups = Object.entries(userData.groups)
                    .filter(([_, groupData]) => groupData.addedBy === userNumber)
                    .map(([_, groupData]) => `‚Ä¢ ${groupData.name}`)
                    .join('\n');
                
                if (myGroups) {
                    await message.reply(`üìã *Vos Groupes (${myGroups.split('\n').length})*\n\n${myGroups}`);
                } else {
                    await message.reply('üì≠ Aucun groupe.\nUtilisez /addgroup dans un groupe pour l\'ajouter.');
                }
                break;
                
            case '/help':
                await message.reply(`ü§ñ *Commandes Disponibles*\n\nüì¢ /broadcast [message] - Diffuser\n‚ûï /addgroup - Ajouter ce groupe\nüìã /mygroups - Voir mes groupes\nüìä /status - Mon statut\n‚ùì /help - Cette aide`);
                break;
        }
        
        // Commande broadcast
        if (messageText.startsWith('/broadcast ')) {
            const broadcastMessage = message.body.substring(11);
            if (!broadcastMessage.trim()) {
                await message.reply('‚ùå Message vide. Usage: /broadcast [votre message]');
                return;
            }
            
            const userGroups = Object.entries(userData.groups)
                .filter(([_, groupData]) => groupData.addedBy === userNumber);
            
            if (userGroups.length === 0) {
                await message.reply('üì≠ Aucun groupe disponible.\nAjoutez des groupes avec /addgroup');
                return;
            }
            
            await message.reply('üöÄ Diffusion en cours...');
            
            let successCount = 0;
            let failCount = 0;
            
            for (const [groupId, groupData] of userGroups) {
                try {
                    await client.sendMessage(groupId, `üì¢ *Message Diffus√©*\n\n${broadcastMessage}\n\n_üë§ Par: ${contact.pushname || contact.number}_\n_üïí ${new Date().toLocaleTimeString('fr-FR')}_`);
                    successCount++;
                    
                    // Pause optimis√©e entre envois
                    await new Promise(resolve => setTimeout(resolve, 1500));
                } catch (error) {
                    console.error(`‚ùå Erreur groupe ${groupData.name}:`, error.message);
                    failCount++;
                }
            }
            
            await message.reply(`üìä *Diffusion Termin√©e*\n\n‚úÖ Envoy√©s: ${successCount}/${userGroups.length}\n${failCount > 0 ? `‚ùå √âchecs: ${failCount}` : 'üéâ Tous envoy√©s!'}`);
        }
        
    } catch (error) {
        console.error('‚ùå Erreur traitement:', error.message);
        if (error.message.includes('Rate limit')) {
            await message.reply('‚è≥ Trop de messages. Attendez quelques secondes.');
        }
    }
});

// Gestion d'erreurs optimis√©e
client.on('auth_failure', (msg) => {
    console.error('‚ùå √âchec authentification:', msg);
    process.exit(1);
});

client.on('disconnected', (reason) => {
    console.log('üîå D√©connect√©:', reason);
    isReady = false;
});

// Gestion propre de l'arr√™t
const gracefulShutdown = () => {
    console.log('\nüõë Arr√™t du bot...');
    saveData();
    client.destroy().then(() => {
        console.log('‚úÖ Bot arr√™t√© proprement');
        process.exit(0);
    });
};

process.on('SIGINT', gracefulShutdown);
process.on('SIGTERM', gracefulShutdown);

// Keep-alive pour Render
const keepAlive = () => {
    setInterval(() => {
        console.log(`üíì Keep-alive: ${new Date().toISOString()}`);
    }, 25 * 60 * 1000); // 25 minutes
};

// Initialisation
console.log('üöÄ D√©marrage Bot WhatsApp Avanc√©...');
console.log('üìç Optimis√© pour Render.com');
loadData();
keepAlive();
client.initialize();
